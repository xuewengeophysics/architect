# 利用深度优先搜索寻找强连通子图

## 1. 先备知识与注意事项

+ **如果一个有向图只有一个强连通分量，则它是强连通的**。
+ 在一个directed graph中，若对于**任意两个**vertex(A)与vertex(B)之间，不是同时存在「从vertex(A)走到vertex(B)」以及「从vertex(B)走到vertex( A)」的path，那么此directed graph就不是strongly connected，里面一定包含了**两个以上**的**strongly connected component(SCC)**。
+ **有向图的强连通分量是一个最大结点集合，对于该集合中的任意一对结点u和v来说，路径u->v和v->u同时存在**；

![20201220_02Code_利用深度优先搜索寻找强连通子图-f1.png](https://github.com/xuewengeophysics/architect/blob/master/AI/greedyai/docs/20201220_02Code_%E5%88%A9%E7%94%A8%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%E5%AF%BB%E6%89%BE%E5%BC%BA%E8%BF%9E%E9%80%9A%E5%AD%90%E5%9B%BE-f1.png?raw=true)    

+ 如图一(a)，经由path:0-1-2-5，可以从vertex(0)走到vertex(5)，但是无论经过任何vertex，都没有办法从vertex(5)走到vertex(0 )，因此，图一(a)的directed graph并不是strongly connected，其中包含了两个以上的SCC(答案是三个)。

![20201220_02Code_利用深度优先搜索寻找强连通子图-f2.png](https://github.com/xuewengeophysics/architect/blob/master/AI/greedyai/20201220_02Code_%E5%88%A9%E7%94%A8%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%E5%AF%BB%E6%89%BE%E5%BC%BA%E8%BF%9E%E9%80%9A%E5%AD%90%E5%9B%BE-f2.png?raw=true)  

+ **G与G T的SCC完全相同**。原因在于，观察G中包含在同一个SCC里的vertex(2)与vertex(3)。G中同时存在「从vertex(2)走到vertex(3)」的path，以及「从vertex(3)走到vertex(2)」的path。在G进行「Transpose」得到G T后，这两条path分别变成与原方向之相反方向，但是存在于vertex(2)与vertex(3)之间的**cycle**仍然存在（按我的理解就是**原路返回**了）。因此，在G里面属于同一个SCC的vertex，在G T里将形成相同的SCC。严谨证明见[参考资料](https://alrightchiu.github.io/SecondRound/graph-li-yong-dfsxun-zhao-strongly-connected-componentscc.html#ref)。



## 2. 只用一次DFS，行不行？



+ 图二(a)，首先以vertex(8)作为`DFS()`的第一次起点，在搜寻完以vertex(8)作为`root`的Depth-First Tree后，再以vertex(5)作为新的起点。同样的，在搜寻完以vertex(5)作为`root`的Depth-First Tree后，再以vertex(3)作为新的起点。
  从图二(a)的「时间轴」可以看出，此次`DFS()`找到了一个Depth-First Forest，其中包含三棵Depth-First Tree，而这三棵Depth-First Tree分别就是Graph中的三个SCC 。

+ 上面的运气真好，一下子就找到了Graph中的三个SCC。但是问题真得解决了吗？透过这么一次`DFS()`就找到了directed graph中的SCC？
+ 再接着看图二(b)，以vertex(0)作为`DFS()`的起点。
  很遗憾，「时间轴」里形成了一整棵Depth-First Tree，directed graph中的三个SCC没有被分开。





+ 由于SCC需要两个方向的path(「vertex(X)到vertex(Y)」和「vertex(Y)到vertex(X)」)都成立，但是`DFS()`只在意「单方向」的edge（**看到这里，是不是很佩服把G转置的idea**），只要存在edge( X,Y)，便把`predecessor[Y]`更新成vertex(X)，在Predecessor Subgraph里，vertex(X)与vertex(Y)便在同一棵Depth-First Tree中。

因此，只有一次`DFS()`的`predecessor`是不够的，图二(a)只是运气好。



## 3. 演算法





## 4. 程序码







## 参考资料

1. [Graph: 利用DFS寻找Strongly Connected Component(SCC)](https://alrightchiu.github.io/SecondRound/graph-li-yong-dfsxun-zhao-strongly-connected-componentscc.html)

